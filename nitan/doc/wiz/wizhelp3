□ 有關品質管制

所有的 Mud 都有自己的風格、發展方向、跟程式碼品質的要求，通常這些要求會
隨著主持這個 Mud 的神而異，但是往往由於每個神對 mudlib 的了解程度不一，
所能對品質要求的深度也不同，為了能夠讓程式碼的品質維持在一個水準以上，最
好能夠制訂出一個最基本的品質要求，以下是東方故事 II 的品質要求：

□ 程式碼

(1) 程式碼必須縮排整齊，縮排一律用 tab (相當於 4 的空格)，雖然縮不縮排
    無關程式是否能夠執行，但是如果你是一個只求程式執行正確，而不管別人
    是否容易閱讀你的程式碼，在 Mud 這樣一個由多人共同發展程式的環境中
    將會十分惹人反感。

(2) 必須沒有編譯時段錯誤，這是非常基本的要求，如果你的區域還有無法正確
    被 load 進來的物件程式，別找神 QC ，否則最輕的懲罰是屁股上一個清楚
    的鞋印。

(3) 在 QC 的大巫師測試過程中，必須沒有執行時段錯誤，區域的作者有義務報告
    所有隱藏的動作、□密，並且經由 QC 的大巫師測試無誤。

(4) 檔案路徑名稱必須和絕對路徑無關，換句話說你的程式必須在整個目錄被移動
    到另一路徑下之後仍然能夠正常動作，你可以用 __DIR__ 這個由 MudOS 提供
    的巨集定義表示這個檔案目前所在的目錄( __FILE__表示目前這個檔案的檔名
    )，即使移動之後必須做修正，最好也限於某個 .h 檔案。

□ 使用者界面

(1) 所有的訊息必須正確而且適當，所謂「正確」是指基於一般常識所應給予的訊
    息必須無誤，例如某人拉下一根拉□，拉拉□的人看到的訊息跟旁觀的人看到
    的訊息就必須正確，所謂「適當」是指訊息出現的地方、訊息的長短、標點符
    號、顏色、出現時間必須盡量合乎真實世界的情形，例如人物 chat 的訊息跟
    add_action的訊息應該要能適當地表達出動作者的立場，不能有看起來怪怪的
    感覺。

(2) 景物或物品的設置必須合理，如一株可以爬的樹你可以把它寫成房間的景物，
    也可以用一個物品來表示樹的存在(可以砍下來帶走)，但是一個可以鑽進去的
    地洞就不應該寫成一個物品。

□ 內容

(1) 人物的強度必須合理，東方故事 II 雖然採開放式的屬性系統，但是另一個重
    點是：NPC 和玩家是同一個世界的人，NPC 的作用不能作為它具有變態能力的
    理由，換句話說 NPC 的「強」必須有故事背景設定上的理由，因為 quest 或
    任何應用上的牽強理由而設計的強力 NPC 會受到最嚴格的檢驗。
    ( 請先參照各門派掌門的強度，作為假設的玩家強度水準上限，NPC 沒有特殊
    理由不應該強過這些人，而且這種強度的 NPC 應該是十分「少見」的。)

(2) 武器裝備的強度必須合理，和 NPC 相同，強力的裝備應該是十分罕見的，如果
    沒有適當的故事背景設定，強力的裝備會受到最嚴格的檢驗，而且這些裝備必
    須是極其罕見的。

(3) 區域的大小與其中所含的「□密」必須成正比，如果你的區域只有一堆用房間
    編輯器做出來的空房間，跟一些用 copy 跟改敘述、數字做出來的 NPC、裝備
    或物品，超過 20 個房間的這種陽春區域通過 QC 的可能性就非常渺茫了。

□ 風格

(1) 一如你所見到的，東方故事 II 的風格應該十分明顯，什麼該有，什麼不該有
    你應該在申請 QC 之前自己再確認幾次，不要讓 QC 的大巫師在你的區域發現
    一罐可口可樂或黑星手槍。

(2) 我們要求區域的設計需要有相當的「原創性」，也許很多武俠小說中的情節、
    人名、地名、武器跟東方故事 II 的風格十分吻合，但是我們希望巫師能用自
    己想出來的東西(甚至最好回避跟一些太出名的作品雷同的東西)，如果你的區
    域是完全出自某部小說或電影，為了避免智慧財產權上可能的爭議與麻煩，這
    種區域開放的可能性非常低。

□ 維修之義務與後續發展

(1) 一但你的區域通過 QC 開放給玩家，這並不表示你的責任就完了，而是更重的
    責任，通常當你的區域開放之後，會將整個目錄搬到 /d 下，並且神還可能會
    給你該目錄的讀寫權，這表示你必須負責這一個區域的維修工作，任何這個區
    域產生的錯誤你都必須負責修護。


□ 繼承

    相信有為數不少的巫師對於  LPC 物件的「多重繼承」感到困惑，這是因為許
多 mudlib 的繼承結構十分混亂，而且沒有固定風格，因此這裡特別說明一下我們
的繼承結構所遵循的風格：

    「任何物件，可以繼承最多一個『標準物件』，和接著標準物件的繼承敘述之
後，若幹個『物件特徵』。」

    其中的『物件特徵』以『標準物件』所未曾繼承過的物件特徵為限，換句話說
一個物件特徵不應該在任何物件中被繼承超過兩次以上。

□ 標準物件 (standard objects)

    也就是位於 /std 下的物件，這些物件如果加上一個適當的 create() 函數就
可以成為一個完整的物件。不過，無論在任何情況下，都不應該對一個標準物件做
clone 的動作，你只能繼承它。

    標準物件作為各式物件的主體，如果一個物件除了標準物件外沒有另外繼承任
何其他的物件特性，而且物件中除了 create() 之外沒有第二個函數，如一般的房
間、怪物、物品等，應該在 create() 函數結束之前，用 replace_program()  將
自己的程式用標準物件取代，因為 create() 只有在物件被創造(或 clone)出來時
執行一次，以後再也用不到了，所以乾脆用所繼承的標準物件取代，這樣可以省下
為數不少的記憶體。

    在某些情形下，一個標準物件只是另一個標準物件與一些物件特性的組合，其
物件本身並不定義其他的函數，如 npc.c，原因是因為我們「常常會用到這樣的組
合」，如果將這樣的組合定義為一個標準物件，就可以用前面提到的在 create()
中用  replace_program 省下不少記憶體，因為標準物件的程式在記憶體中只存一
份而已。

□ 物件特性 (features)

    也就是 /feature 下的物件，這些物件只是提供單一的屬性模組，是純粹用來
被繼承的物件，當然，絕對不應該去 clone 它，你只能繼承它。

    定義物件特性的原則是「模組化」，也就是說，要能盡量在獨立於標準物件外
的情形下工作，雖然完全獨立是不可能的，但「盡量就是」。物件特性，顧名思義
，提供的是一項特性(如 equip.c)、特殊功能(如 alias.c, more.c)、或一些相互
關連密切的函數組成的模組(如 attack.c) ，如果所要描述的特性具有能讓許多不
同物件使用的性質，應該優先把它寫成一個物件特性，反之，則把它寫成一個標準
物件。

    好了，看了這麼多文謅謅的定義，我們用一個例子來解釋「標準物件」和「物
件特性」的意義。比方說我們要寫一個能夠裝備的劍之精靈(生物)，用以下的繼承
方式定義：

    inherit NPC;        // 標準物件 NPC
    inherit F_EQUIP;    // 物件特性 「可裝備」

    聰明的你，到這裡應該看得出這種組合的彈性了吧，因為  NPC 並不具有能讓
不同物件使用的性質，因此我們把它寫成標準物件，而「可裝備」因為具有這種性
質，所以寫成一個物件特性，如果在傳統的 mudlib ，monster.c 與 weapon.c 都
是「標準物件」型的物件，就算有哪位巫師膽敢同時繼承這兩個檔案，後果一定相
當可怕。

    如果你細心的話，其實可以發現分析到最後，一個最基本的標準物件只是幾個
物件特性的組合，所謂的標準物件事實上是將一些物件特性「包裝」起來，所以理
想中應該「盡量避免」在標準物件中定義函數，但是也不必過分地硬將所有的標準
物件拆開成一些奇怪的物件特性，這些東西可能和遊戲系統規劃者的思考方式與個
人喜好有關，總而言之，「簡單」「合理」「富彈性」應該是設計繼承結構的主要
考量。

□ 技能系統

我們使用的技能系統是屬於多元成長途徑的系統，有別於傳統用經驗值換取等級的
方式，一個技能由兩個數值來描述：「等級」與「學習點數」，平常使用時只看等
級，學習點數完全不影響技能的效力。

由於技能的性質不同，我們將技能分為兩大類：基本技能跟特殊技能，基本技能又
可以稱為技能種類，所有的特殊技能都必須有至少一種的基本技能為基礎，舉例來
說，「xx劍法」是一種特殊技能，以「基本劍術」、「拆招卸力之法」為基礎，這
個意思是說，這種劍法可以被「使用」在劍術與拆招卸力的用途上，並不是說必須
先學過基本劍術與拆招卸力之法才能學這個劍術，有關技能的學習限制完全由技能
本身定義，系統不預作假設。

通常我們公式中計算技能等級的時候，使用的是一種稱為「有效等級」的計算方式
，所謂的有效等級，是以「技能種類」(基本技能)為索引的，特殊技能沒有有效等
級，因為有效等級的計算是合並 □ 基本技能、□ 被「致能」的特殊技能， 以及
 □ 裝備、法術等其他影響，所計算出來的，其中基本技能的等級以二分之一計算
，特殊技能以原來等級計算，裝備及其他法術影響以修正值計算(可正可負)。大概
的公式如下：

  有效等級 = (基本技能 / 2) + 特殊技能(enabled) + 修正值

大多數的公式中所稱的「技能等級」指的便是上面的有效等級。

□ 技能定義

所有的技能包括基本技能與特殊技能，我們都用一個物件來定義，定義技能的物件
必須繼承標準技能物件 SKILL，並且定義以下幾個函數：

string type()

  傳回技能的型態，目前有 "knowledge"、"martial" 兩種，其中 "martial" 型態
  的技能 learn 指令會自動限制當實戰經驗小於技能(不是有效技能)三次方的時候
  不能學習。

int valid_learn(object me)

  檢查 me 是否有學習這項技能的條件，這裡的學習包括 learn, study, practice
  ，但是不包括經由使用而進步的情形。如果合乎條件，傳回 1，否則傳回 0。

int valid_enable(string usage)

  檢查這個技能是否可以用在 usage 的用途上，若是，傳回 1，否則傳回 0。

int practice_skill(object me)

  讓一個人物「練習」一個技能，這個函數是由 practice 指令呼叫，作為技能物件
  的處理函數。

void skill_improved(object me)

  每當一個人物的技能等級提升了，就會呼叫這個函數，你可以在這裡面做一些跟等
  級相關的改變或獎勵。

□ 物件特性

    物件特性的使用方法大部分是經由特定函數，每個物件特性各不相同，因此
這裡也沒什麼好說的，只是提供幾個以後當你要加入新的物件特性時，最好要遵
守的原則：

(1) 簡單

    當你發現一個物件特性寫下來將是一個 10K 以上的大檔案時，想辦法縮短
    或拆成兩個特性，盡量維持一個特性所提供的功能單純化。

(2) 記憶體

    請你記得物件特性是被繼承的，而繼承這個特性的物件將會 copy 一份所有
    宣告在這個特性中的 global variables ，因此如果一個特性中需要用到許
    多具有常數性質的變數( 即，執行過程中不隨繼承這個特性的物件而變 )，
    試著用 daemon 的形式以節省記憶體，如 ALIAS_D，SKILL_D 等。

(3) 效率

    採用物件特性的一個原因就是避免「深層繼承」，雖然 driver 在執行上並
    沒有太大的差異，但是對於大部分巫師而言，要了解或除錯一個繼承得亂七
    八糟的物件是相當困難的，盡量用「一個標準物件加若幹個物件特性」的模
    式去定義所有物件。

□ ACTION

varargs void start_busy(mixed new_busy, mixed new_interrupt)

nomask int is_busy() { return busy != 0; }
判定使用者是否正忙著做某件事.

void continue_action()
如果戰鬥中使用者有 busy 著個 flag, 則 heart_beat() 會改呼叫這個函
數.

This function will be called in the place of attack() during
combat to indicate a person is in busy statue.

void interrupt_me(object who, string how)
This function interrupts whatever the user is doing.

int start_call_out(function fun, int delay)
開始執行 call_out, 將傳入的函數名稱及延遲時間傳給 call_out() 這個
函數, 並於時間到時執行該函數.

void eval_function(function fun) { evaluate(fun); }
執行某個函數.

Evaluate the function named fun. (a fun function :)

□  ALIAS -- 替代指令

MAX_REPEAT 30  : 最多同一個指令可以重覆的數量.
MAX_ALIASES 40 : 可設定的替代指令數量.
HISTORY_BUFFER_SIZE 10 : 系統記憶指令的數量.

string process_input(string str)
處裡輸入指令.
如果使用者已輸入超過 MAX_REPEAT 所定義的數量的相同指令, 系統會強迫使
用者離開.
接下來系統會判定使用者是否要重覆使用前面用過的指令, 再來會核對使用者
自己所設定的替代指令表, 若有找到符合的則將輸入的替代指令擴張為完整的
指令. 傳回值為處理過後的輸入指令. 若以上條件都不符合則呼叫 ALIAS_D
的 process_global_alias() 函數並將結果做為此函數的傳回值.

int set_alias(string verb, string replace)
將新的替代指令加入替代指令列表. 若沒有傳入第二個參數, 則取消所傳入之
替代指令的設定, 並確定使用者沒有超過替代指令數量的上限.

mapping query_all_alias()
傳回物件所設定的替代指令.

□APPRENTICE

int is_apprentice_of(object ob)
判定指定入物件是否為傳入物件的弟子.

void assign_apprentice(string title, int privs)
設定物件在所屬門派地位及抬頭. -1 表示物件為掌門人, 0 表是物件為弟子.

void create_family(string family_name, int generation, string title)
建立一個 mapping 來儲存物件的門派資料, 並設定指定物件為掌門人.

int recruit_apprentice(object ob)
設定傳入物件為指定物件的弟子並設定相關資料.

□ F_AUTLOAD

void clean_up_autoload()
將 autoload 陣列清除掉.

void save_autoload()
過慮所有在某物件 inventory 中的物品, 如果 query_autoload() 有傳回
值則將物品的檔案名稱及其傳回值存入 autoload 陣列中.

void restore_autoload()
讀取一個物件的 autoload 陣列並試圖復制所存的物品. 若失敗則會顯示錯
誤訊息並將訊息存入 /log/AUTOLOAD 檔中.

□ F_CLEAN_UP - 提供繼承這項特徵的物件一個標準的 clean_up 函數。

    每當一個物件在隔了一段固定長度時間沒有被其他物件參考到，MudOS 會呼
叫該物件的 clean_up 函數以檢查這個物件是否有繼續存在的必要，也就是說，
如果這個物件有一段時間沒有被使用到，也許物件已經沒有用了，可以將它從記
憶體中清除以節省空間，例如：一個很久沒有人走過的房間。

    clean up 時間的長短是在 MudOS 的 runtime config 檔裡設定的。所有可
以被 clone 的物件、房間、指令處理物件、以及非長駐型 daemon都應該要繼承
這項特徵以便能在物件不被使用到時加以摧毀並釋放出所佔記憶體。

    當此函數傳回 1 時，意思是告訴 MudOS 「我現在暫時要繼續留在記憶體中
，但是如果再隔一段固定長度時間這個物件仍然沒有被其他物件參考到，請你再
呼叫一次我的 clean_up() 函數」，若傳回 0 或是 clean_up  函數沒有被定義
，則 MudOS 會假設這個物件不需要 clean up這種服務，以後就不會再呼叫這個
物件的 clean_up()。

標準的 clean_up() 判定程序：

    首先，如果這個物件是一個使用者 (用 interactive() 決定)，此函數傳回
 1，因為使用者發呆過久是在 heart beat 裡處理的。

    接下來，如果這個物件是在另一個物件裡，例如一個房間裡的怪物、袋子裡
的物品等等，我們改呼叫含有這個物件的房間或袋子的 clean_up() ，這樣做有
兩個主要理由：如果同一個房間裡有不能被 clean up 的物件，如玩家，那麼我
們不希望任何物件在他們面前憑空消失，而且，如果一個存在於另一物件中的物
件能夠被清除，容納它的物件必定也能夠被清除，如果容納它的物件不能被清除
，那麼這個物件也必定不能被清除，如玩家身上的物件，因此我們讓容納這個物
件的物件來決定要不要清除，因為清除一個物件的同時，也會清除這個物件裡的
所有物件。

    如果這個物件並不是在另一個物件裡，而是一個房間，我們還必須檢查是否
有玩家在這個房間裡，以免玩家發呆了一會兒就被踢到最後樂園去。

    最後，經過以上各個關卡，我們判定這個物件已經沒有存在的必要，所以我
們將這個物件摧毀，傳回 0 用以告知 MudOS 這個物件已經「不見了」以後不用
再檢查它是否需要 clean up  。

□ F_COMMAND

init_command_hook()
經由 add_action, 將所有 user 輸入東西傳入 command_hook() 這個函數.
本函數沒有傳回值.

find_command(string verb)
呼叫 command daemon (COMMAND_D) 看看在指定路徑內是否有跟 verb 同名
的檔案, 若有, 傳回檔名.

command_hook(string arg)
一但使用者輸入一行文字, driver 會將除了第一 個字以外的文字當成參數
(arg) 並傳至此函數. 輸入的第一個字就是所謂的動詞 (verb). 通常是 一
個指令.接下來我們經由 query_verb()  得到 這個動詞, 也就是使用者所輸
入的第一個字.然後開始判定使用者輸入這行文字的目的. 首先我們將動詞傳
入 find_command()看看在使用者的路徑設定中是否有與這個動詞相同的指令
檔名, 如果有, 則試著以call_other()  去呼叫 該檔名的 main() 函數並傳
入參數 arg 及動作人 物件.如果成功, 則結束離開. 不符合上述條件者, 本
函數在此呼叫 EMOTE_D ( emotedaemon), 判別這個動詞是不是 emote 之一,
如果不是的話則呼叫管理交談頻道的 daemon, (CHANNEL_D) 看看這個是不是
交談頻道用的指令. 最後, 我們來判定這是不是使用者用來移動的 的指令 (
如: 東, 南, 西, 北等等). 如果以上皆非, 那我們就傳回 0, 有可能這個使
用者輸入了一個不存在的指令.

如果 PROFILE_COMMANDS 有定義的話, 有關這個指令的使用情形會由
PROFILE_D記錄下來並存於指定檔案中.

set_path(string *p)
將 *p 指定為路徑. *p 為陣列型態.

force_me(string cmd)
強迫動作物件執行一個指令, 呼叫此函數的物件需要有 ROOT UID 才會成功.

□ DAMAGE

int is_ghost()
判斷物件是否為鬼魂.

varargs int receive_damage(string type, int damage, object who)
讓物件某項狀況的數值減少. damage 不得為負數. 本函數會檢查傷害種類是
否合法後將物件的狀況數值減少, 若最後值低於零則設為 -1. 最後, 打開物
件的心跳 (heart_beat).

varargs int receive_wound(string type, int damage, object who)
同 receive_damage. 但傷害是加在狀態值上 (eff_xxx).

varargs int receive_heal(string type, int heal)
同 receive damage, 但作用相反, 本函數是將某個數值加入狀況的數值上.

varargs int receive_curing(string type, int heal)
同 receive_wound, 但作用相反, 本函數是將數值加入狀態值上, 相當於
醫療.

void unconcious()
把某個物件弄昏, 判別及執行步驟如下: 沒有生命的物件不能設, 如果物件
是因為受傷而昏的, 呼叫在 COMBAT_D 中的 winner_reward() 以處理勝力
者的獎賞.. etc. 刪除指定物件的敵人表, 送出相關訊息 (讓在場的大家都
知道) 將精氣神等狀態設為0, 關閉指定物件接受訊息的的權力, 最後設定
清醒的時間, 放到 call_out 上.

varargs void revive(int quiet)
把某人弄醒. 如果 call_out 還在, 刪掉他. 如果清醒的物件本來是在另一
個使用者的 inventory 中, 將之移到使用者的環境中. 呼叫 enable_player()
以設定玩家的指令和相關設定, 傳出對應的訊息並將訊息管道打開. 若傳入
值 quiet 為 1, 則清醒的訊息不會送出.

void die()
死了...
如果物件是昏迷不醒的狀況, 先把他弄醒. 獎勵殺人者 (hmm...) 並制造一
具□體, 把 killer 表刪除, 如果死者是玩家, 則把他設為鬼魂並送到陰間
去, 否則直接摧毀該物件.

void reincarnate()
復活...
將物件的 ghost 標記去掉. 身體的各項狀態值設為上限.

int heal_up()
update all status (gin, kee, sen, fp, mp, ap.. etc)

□ F_DBASE 物件資料特性

mixed set(string prop, mixed data)
將屬性 prop 的內容設為 data 並存入 dbase mapping 中, 如果 dbase
不存在的話則會建立一個新的 dbase.

varargs mixed query(string prop, int raw)
傳回屬性 prop 的內容, 如果該屬性不存在或是 dbase 不存在則傳回 0.
第二個傳入值可有可無, 如果 raw 值為 1, 則傳回值為 prop 所呼叫的
函式名稱, 否則傳回該函式的傳回值.

int delete(string prop)
將屬性 prop 從 dbase 中刪除.

mixed add(string prop, mixed data)
將 data 加入屬性 prop 的內容, 如果該屬性不存在, 則呼叫與
set(prop, data) 相同.

int set_temp(string prop, mixed data)
將臨時屬性 prop 的內容設為 data 並存入 tmp_dbase mapping 中, 如果
tmp_dbase 不存在的話則會建立一個新的 tmp_dbase.
tmp_dbase 為臨時性的資料庫.

 mixed query_temp(string prop)
傳回臨時屬性 prop 的內容.

int delete_temp(string prop)
將臨時屬性 prop 從 tmp_dbase 中刪除.

mixed add_temp(string prop, mixed data)
將 data 加入臨時屬性 prop 的內容, 如果該屬性不存在, 則與呼叫
set(prop, data) 相同.

mapping query_entire_dbase()
傳回整個 dbase 的內容.

void set_default_object(mixed ob)


□ F_EDIT

int edit(function callback)
開始編輯程式。

void input_line(string line, string text, function callback)
由編輯程式呼叫此函數，將使用者所輸入的文字或指令作適當的回應，當使用者結
述輸入時，傳入的函數 callback 將會被執行。

□ EQUIP

int wear()
判斷一個物件是否可以裝備物品. 物件必需是一個人物 (以 is_character()
判定), 想穿的物件必需是可以穿的... 等等. 系統會檢查是否已經穿了同
類型的護具, 判斷成功後設定所有穿上護具後的資料.

int wield()
判斷一個物件是否可以裝備武器. 物件必需是一個人物 (以 is_character()
判定), 想想使用的物件必需是武器... 等等. 系統會檢查是否有空出來的手
來拿這樣武器. 如果判斷成功則設定所有使用武器後的資料.

int unequip()
將穿著的護具或武器脫掉或放下.

□ F_FINANCE

int can_afford(int amount)
這個函數是用來判定一個物件 (this_object()) 是否付得起 amount 這個價錢.
若傳回 0 表示這個物件並沒有這麼多錢, 傳回 1 表示物件有這麼多錢, 而且
有正確的錢幣種類. 傳回 2 則表示此物件雖然有足夠的錢, 卻沒有正確的錢幣
種類.

□ MESSAGE -- 訊息

MAX_MSG_BUFFER 500      最多可以儲存的暫存訊息行數.

void receive_message(string msgclass, string msg)
如果收到訊息的物件不是玩家, 則將所有傳入的參數傳給 relay_message()
函數. 接下來判定這段訊息是否為交談頻道或是有關天氣的訊息, 並判定使
用者是否可以收到這些訊息. 再來則判定接受訊息的玩家是否有設定任何阻
檔訊息的屬性, 並依此決定該玩家是否可以收到該訊息. 最後, 如果玩家正
在編輯檔案或輸入模式中, 則將訊息送至暫存空間存放. 如果判定使用者可
以接受這段訊息, 則呼叫 receive() 函數並將訊息傳入.

void write_prompt()
寫入使用者的下一個 prompt, 若使用者有暫存訊息還未輸出則先將該訊息
傳給使用者.

void receive_snoop()
將監看時對方所看到的訊息前面加上 % 符號以示區別.

□ F_MORE

void more(string cmd, string *text, int line)
將傳入的文字陣列一行一行的顯示出來，並依照使用者所輸入的指令動作。

void start_more(string msg)
開使執行 more，將傳入的字串一行一行的分開以方便顯示。

□ F_NAME

void set_name(string name, string *id)

將 name 字串設入物件的 name 屬性中. 如果該物件還沒有設 id 屬性,
則取傳入之 id 陣列的第一個 (id[0]) 元素為該物件的 id. 並將 my_id
陣列設為傳入之 id 陣列的值.

int id(string str)
如果 "apply/id" 這個臨時屬性存在且不是空字串的話, 表示這個物件正在假冒
別的物件, 我們就用 applied_id □的內容來當這個物件的 id, 如果有找到的
話傳回 1. 否則傳回 0. 這樣可以避免「冒牌貨」在 id 指令下見光死.
如果沒有 "apply/id", 則以 my_id 的內容來判定. 如果 str 與 my_id 陣列中
的某個元素相同, 則傳回 1, 否則傳回 0.

string *parse_command_id_list() { return my_id; }
如果 "apply/id" 這個臨時屬性存在且不是空字串的話, 傳回 applied_id 陣列
的所有內容. 否則傳回 my_id 陣列的內容.

varargs string name(int raw)
如果物件有 "apply/name" 這個臨時屬性而且不是空的的話, 則傳回值為 mask
這個陣列的倒數第二項元素.
如果物件有 "name" 這個屬性, 傳回值為 "name" 的內容. 否則傳回這個物件的
檔名.

varargs string short(int raw)
如果該物件設有 short 這個屬性, 則傳回字串為 short 的內容加上 id. 否則
傳回字串為該物件 name 屬性的內容加上 id. 如果該物件不是人物 (由
is_chaaracter() 判定) 則在此傳回字串的內容.
如果這個物件有 "apply/short" 這個臨時屬性且內容不是空的, 則傳回字串被
設為 "apply/short" 陣列的倒數第二個元素. 否則傳回字串會將物件的 nickname
及 title 等屬性加以組合. 最後判定這個物件是否在斷線中, 輸入文字中, 編
輯檔案中或是昏迷不醒, 並將適當的字串加入先前的字串一起傳回.

varargs string long(int raw)
如果這個物件有 "apply/long" 這個臨時屬性且內容不是空的, 則傳回 "apply/long"
陣列的倒數第二個元素. 否則傳回 "long" 這個屬性的內容. 若該物件沒有 "long"
這個屬性, 則呼叫並傳回 short() 函數的內容並加上 "。\n".

□ F_SAVE

int save()
判定物件的存檔檔名並將該物件存檔。

int restore()
將物件的資料由檔案內載入。

□ SKILL

mapping query_skills()
傳回物件的所有技能.

mapping query_learned()
傳回所有技能的學習點數.

void set_skill(string skill, int val)
設定技能. 傳入技能名稱及等級, 若技能的 mapping 不存在則新建立一個,
否則直接設入技能名稱及等級.

int delete_skill(string skill)
刪除某項技能. 連帶的也會刪除該項技能的學習點數.

varargs void map_skill(string skill, string mapped_to)
把某項技能致能, 若第二個參數沒有傳入, 則取消該項致能.

string query_skill_mapped(string skill)
傳回某項技能種類所致能的技能名稱.

Returns the name of the skill that is enabled as as skill type
passed as parameter.

varargs int query_skill(string skill, int raw)
傳回技能的等級.

mapping query_skill_map()
傳回技能致能的列表.


int skill_death_penalty()
人物死後會呼叫這個函數以計算死亡時所造成的技能損失.

varargs void improve_skill(string skill, int amount, int weak_mode)
增家傳入技能的學習點數, 並判定是否有進步以增加等級.

□ team

int set_leader(object ob)
將傳入物件設為該隊伍的領隊。

object query_leader()
傳回隊伍的領隊物件。

int follow_path(string dir)
讓指定物件執行移動指令，方向以傳入值為主。

int follow_me(object ob, string dir)

int add_team_member(object ob)
將指定物件加入隊伍中。如果隊伍還不存在，則會建立一個新的隊伍，並把呼叫此函
數的物件和傳入物件納入隊伍之中。

int set_team(object *t)
設定隊伍。（注：此函數沒有傳回值。）(未完)

varargs int dismiss_team(object ob)
解散隊伍。若解散人為這個隊伍的領隊，則整個隊伍會被解散。否則僅該成
員離開隊伍。

object *query_team()
傳回隊伍□所有隊員。

int is_team_leader()
測試指定物件是否為一個隊伍的領隊。


□ VENDOR -- 標準販賣物件

int buy_object(object me, string what)
(為完)

void complete_trade(object me, string what)
完成交易, 將物件交給買主並傳出相關訊息.

string price_string(int v)
以對等的幣值列出物件的價值.

int do_vendor_list(string arg)
列出所出售的物品及價錢.

□ 人物症狀

所謂的症狀(condition)就是一個人物因為受傷、中毒、或法術影響所產生的
各種症狀，在 ES2 mudlib 裡面定義成「需要每次 recover 時變化的症狀」
，換句話說，人物症狀是一種相當耗費系統 CPU 時間的物件，而且一發生錯
誤就可能導致 lost heart beat。

將一個症狀加到一個人物身上十分簡單，人物物件繼承的 F_CONDITION 中定
義了一個界面函數 apply_condition() 讓你將一個症狀加諸於該名人物身上
，這個函數第一個參數是定義這個症狀的物件檔名，第二個參數則是一個
mixed 型態的任意參數，用來描述這名人物此一症狀的資訊。

apply_condition 之所以用這種和 function 比較起來較慢的格式來定義一個
症狀，主要是為了讓人物的症狀狀態能被 save_object() 儲存下來，因此當
你設計新的症狀時，請注意描述這個人物症狀的參數中不要使用 object 型態
的欄位，以免在 save 及 restore 之後失去這個欄位的內容。

定義症狀的物件十分簡單，F_CONDITION 在每次人物 recover 時間到，呼叫
heal_up() 之前，會對人物所有的症狀之定義物件呼叫 update_condition()
這個自定函數，呼叫傳入兩個參數，第一個是 object 型態，也就是帶有這個
症狀的人物，第二個則是用來記錄這名人物該症狀資訊的 mixed 型態參數，
你在症狀定義物件中宣告第二個參數的時候可以任意指定它的型態，F_CONDITION
並不會對這個變數做任何處理。

update_condition() 的傳回值是一個表示多個 flag 的整數，這些 flag 都定
義在 <condition.h> 中，如果傳回值為 0，這個症狀會在 return 之後被從這
名人物身上移除(這樣設計可以讓錯誤的症狀定義物件檔名在一次呼叫之後立刻
被移除)。

CND_CONTINUE    若傳回值的這個 flag 為 on，則下次 recover 時這個症狀
                會再次被呼叫。

□ 動作(action)

    這裡所謂的「動作」(action)，是指生物戰鬥時的行為的最小單位，可以是揮出
一拳、踢出一腳、用劍一刺、射出一支飛鏢、丟出一個火球、甚至是□試一次逃跑等
等，只要是邏輯上屬於「同一時間」所作的行為，都可以歸類於一個動作。

    我們假設所有的動作都是在戰鬥狀態下的行為，因為非戰鬥狀態下的動作直接做
出來就可以了，不需要花心思用以下將提到的格式描述它。反過來說，把戰鬥狀態下
的行為統一用「動作」來描述的理由很簡單，我們不希望一個人可以藉由任何巫師意
料之外的技巧在敵人揮出一劍的同時，丟出十個火球、撿起地上的三十瓶藥劑、等等
情形發生，另一方面，也提供巫師們在設計怪物、武器、物品等物件時，可以用比較
輕鬆的方式定義出一些變化較大的表現方式。

    在程式中，我們用一個 mapping 來表示一個動作，值得一提的是，由於mapping
這種結構在 LPC 中是以位址傳遞(call by address)，因此為了安全起見，我們規定
所有處理動作的程式「絕不」修改其他物件所提供的動作 mapping 的內容 ，這個原
則是預防一些未來可能發生的錯誤出現。

    在定義一個動作的 mapping 中，可能有以下的欄位，其中前面有 * 號的表示這
個欄位是可有可無的：

action

    執行這個動作所出現的訊息，格式是和 message_vision 這個 simul efun 要求
    的相同，例如 "$N對準$n的%s揮出一拳" ，其中的 %s 會用這個動作所攻擊的部
    位名稱代替。

*post_action

    這是一個 function type 的欄位，如果這個欄位被定義，combatd 會在 action
    訊息印出之後呼叫這個 function，有不少戰鬥中的特殊效果都是利用這個方式
    完成，如投射武器的消耗、某些戰鬥用的魔法等。

*damage

    執行這個動作的傷害力修正，單位是百分比，□圍是大於 -100。
    default: 0

*damage_type

    攻擊命中時所造成的傷害種類，如"割傷"、"瘀傷"、"灼傷"等等，詳細的傷害種
    類請參考其他文件。
    default: "傷害"

*dodge

    這個動作對敵人躲避此一攻擊的修正百分率。
    default: 0

*parry

    這個動作對敵人招架此一攻擊的修正百分率。
    default: 0

□ 人物狀態

一個人物具有三項基本的數值：形體(Physical)、能量(Energy)、精神(Mental)。

每一個數值都有一個「目前值」，表示該狀態在計算人物能力時所具有的強度，一個
「有效上限」，表示這個狀態在人物自然的情況下，能夠經由新陳代謝或自我修復的
機能慢慢恢復的上限，跟一個「最大上限」，表示這個人物該項狀態的極大值。

這三個值的高低永遠是：目前值 ≦ 有效上限 ≦ 最大上限。

□  Phisical 形體

形體的目前值表示一個人物形體(身體機能)的機能狀態，形體機能會因為作戰時的阻
擋、承受攻擊而降低，形體目前值降到零表示這個人物的形體機能完全喪失作用，也
就是死亡狀態(dead)。
形體的有效上限表示一個人物形體的完好程度，形體有效上限會隨著人物受到實體傷
害( 物理性傷害 )而降低，形體有效上限降到零表示這個人物的形體已經被摧毀、報
廢了，也就是毀滅狀態(destroyed)。

□ Energy   能量

能量的目前值表示一個人物體力(動力)的目前狀態，能量會因為進行攻擊、或各種消
耗體力的動作而降低，能量降到零表示這個人物已經體力透支(動力喪失)，而成為癱
瘓狀態(exhausted)。
能量的有效上限表示一個人物體能(能源)的狀態，體能會因為受到能量型武器、氣功
等能量攻擊而降低，能量的有效上限降到零表示人物的體能耗竭(能源耗盡)，而成為
衰竭狀態(withered)。

□ Mental   精神

精神的目前值表示一個人物的集中力目前的狀態，精神力會因為使用魔法、或進行需
要腦力的工作而降低，精神降到零表示這個人物已經累倒了，進入昏睡狀態(asleep)
。
精神的有效上限表示一個人的意志力、魔力狀態，精神上限會因為受到催眠、藥物的
副作用、魔法的精神攻擊等影響而降低，當這個有效上限值降到零表示這個人物的精
神已經崩潰，而陷入瘋狂狀態(insane)。

□ 關於生命型態

並不是所有的生命型態對於上面三個狀態都有定義，換句話說，有些狀態對某些生命
型態是不具意義的( 這裡的生命型態包括機器人在內 )。

□ 形體

   對於精神體的生物如鬼魂(Ghost)而言，形體是沒有意義的，因此精神體的生物不
   會受到形體的傷害，因此也不會有死亡或毀滅的狀態。

   對於不死生物(Undead)而言，其活動的原理跟形體的機能無關，故形體是無目前值
   的，因此不死生物沒有死亡狀態，只有毀滅狀態。

□ 能量

   對於魔法驅動的生物如 Golem 而言，其能量來自施法者的意志，自身的能量是沒
   有意義的，因此魔法驅動的生物沒有癱瘓跟衰竭的狀態。

   對於非機械體的人造人而言，能量是無目前值的(動力恆定)，因此非機械體人造人
   不會癱瘓，只有衰竭(如魔鬼終結者 T-2000、七龍珠的人造人)。

□ 精神

   對於純機械人而言，精神是沒有意義的，因此純機械人不會昏睡或瘋狂。

   對於不死生物而言，其精神是來自其成為不死生物時的咒文之力量，因此精神沒有
   目前值，不會昏睡，只有瘋狂(如：Lich 施法術沒有法力限制)。

由上面的例子我們可以看出每個狀態除了前面定義中描述的行為之外，還有「無定義」
跟「目前值與有效上限恆一致」的情形。

在「無定義」的情況下，該型態的生命無法使用消耗該狀態目前值的技能，如純機器人
不能使用魔法、魔法驅動生物不能使用氣功、精神體生物不能使用裝備。同時，這種生
物也不會受到降低該狀態目前值、有效上限的傷害，如純機器人對催眠沒有反應，魔法
驅動生物不怕氣功(能量型武器可能同時造成形體傷害)，精神體生物不怕物理性攻擊。

□ 房間屬性

"short"                                                         (string)

    房間的短敘述。

"long"                                                          (string)

    房間的長敘述。

"item_desc"                                                     (mapping)

    房間中個別景物的敘述，格式為：([ <景物名稱>:<景物敘述>, .... ])。
    其中<景物敘述>可以是字串或 function type。

"exits"                                                         (mapping)

    房間的出口，包括有門的方向，格式為：([  <出口>:<房間檔名>, .... ])。

"objects"                                                       (mapping)

    房間中的物品、生物，格式：([ <物品或生物檔名>:<數量>, .... ])。

"outdoors"                                                      (string)

    房間是否為「戶外」，戶外房間可以看到天色變化與氣候影響。字串的意義
    表示房間的氣候區，通常和該區域的 domain (即 /d 下的目錄名稱) 同。

"no_fight"                                                      (int)

    房間是為禁止作戰區域。

"no_magic"                                                      (int)

    房間是為禁止施法區域。

□ 武器屬性

"skill_type"                                                    (string)

    這個武器所屬的技能種類，如 "sword"、"blade" 等，要注意在 /d/skill
    下必須有一個定義該武器技能的物件，否則裝備這個武器戰鬥時會有錯誤
    訊息。

"rigidity"                                                      (int)

    武器的硬度，當使用武器相鬥時，硬度、武器的重量、持用者的力量將會影
    響武器受損的機率。
    武器受損機會所用的強度值計算公式如下：

        重量/500 + 硬度 + 力量

"weapon_prop"                                                   (mapping)

    武器對持用者的狀態影響，通常武器只影響 "damage"，這些狀態影響會在
    武器被裝備時用 add_temp() 加到持用者的 apply 上，並於卸除或 dest
    時減回來。

"flag"                                                          (int)

    武器的一些型態旗標.

□ 以下是目前允許的護具種類：

head    頭部護具，凡是戴在頭上的都算，包括頭巾、耳環、頭盔、帽子等等。
neck    帶在頸子上的護具或飾物，項□、護身符、圍巾等等。
cloth   穿在身上的輕便型衣物，包括上衣跟褲子整套。
armor   鎧甲、穿在 cloth 外面，也是包括上半身與下半身整套。
surcoat 外套、穿在鎧甲外面。
waist   腰部護具，包括腰帶、腰巾。
wrists  手腕護具，如手鐲、護腕。
shield  盾牌，不用解釋了吧。
finger  戒指，只有戴在右手無名指的戒指才能發揮效力，所以只能戴一個。
hands   手部護具。
boots   足部護具，鞋類。

□ 物品屬性

"name"                                                          (string)

    物品的中文名稱。

"id"                                                            (string)

    物品的英文名稱。

"long"                                                          (string)

    物品的詳細描述。

"value"                                                         (int)

    物品的價值，單位是「錢」(coin)。

"unit"                                                          (string)

    物品的單位，如：個、把、枝.....

"no_get"                                                        (int)

    表示物品是否可被撿起來。

"no_drop"                                                       (int string)

    表示物品是否可被丟棄，如果型態是 string, 則當有人企圖丟棄這個物品時
    會將該字串用 notify_fail 傳回去。

□ 定義在人物物件中的附加函數(apply functions)

void defeated_enemy(object victim)

當這名人物打昏一個敵人的時候會呼叫這個附加函數，victim 即是被打昏的的
敵人物件。
呼叫者: COMBAT_D
有預設定義此一函數的系統物件: none

void killed_enemy(object victim)

當這名人物殺死一個敵人的時候會呼叫這個附加函數，victim 是即將要被殺死
的敵人物件。
呼叫者: COMBAT_D
有預設定義此一函數的系統物件: none

int accept_fight(object who)

當有其他生物對這個人物下 fight 指令的時候，會呼叫這個附加函數，who 是
下 fight 指令的生物，如果是對 player 下，"fight" 指令會直接顯示訊息徵
求被挑戰一方的同意，如果是對 NPC 下這個指令，則當這個附加函數傳回 1
時才會接受挑戰，否則顯示某某不想跟你較量的訊息。
呼叫者: "fight" 指令
有預設定義此一函數的系統物件: NPC

int accept_object(object who, object item)

當有人用 give 指令給這個非玩家人物東西時，會呼叫這個附加函數，傳回 1
表示願意接受這個東西，傳回 0 表示不接受。
呼叫者: "give" 指令
有預設定義此一函數的系統物件: none

void recruit_apprentice(objct apprentice)

當一個人物收了另一個人物做弟子時會呼叫這個附加函數，你可以在這個函數裡
修改弟子的 rank 或其他東西。
呼叫者: "apprentice" 指令
有預設定義此一函數的系統物件: none

□ 評價系統

假設在一個集合中有個數為 N 的相異個體( N 種 NPC 或 player )，每一個
個體具有「評價」與「能力」兩種數值屬性。

評價一開始的初始值一律是 0，能力的數值則不在這個系統的關心□圍。

假設這個系統從 t = 0 開始，每單位時間內會發生若幹個「戰鬥」，戰鬥的
發生為一機率密度固定的事件，即，不考慮瞬間發生大量戰鬥的情形。

戰鬥: 任取系統中兩個相異個體，戰鬥過程不考慮，只取「產生一勝一負」的
      情形為有效樣本，並作為一次評價變動的輸入，任一個體得勝的機率和
      其「能力」成正比，和敵方的「能力」成反比。

評價變動: 得勝的一方視雙方「目前的評價」的比值獲得若幹評價，負方的評
          價不變動。

試求一合適之評價變動公式，使得在經過一段時間後，該集合中個體的「評價」
和「能力」能成正比(以能力和評價為 x, y 軸，每個個體描一個點，會呈現線
性分布)。

□  如何建造一個房間

    房間是構成這整個世界的要素之一，在此我們提供了一個房間的標準物件來讓
所有的房間繼承。而如同其他的物件一般，你需要寫一個 create() 來設定房間中
的敘述、出口、物品、生物等等。這裡，我喜歡說你用 create() 這個函式來賦予
這個房間的屬性。一般來說，要建造一個簡單的房間，你只要賦予它基本的屬性即
可。當然，我們不認為一個區域中幾十個房間沒有任何的機關或秘密，是個會吸引
玩家一遊的好地方。

    下面，提到了一些建造房間所需要留意的事項，也會配合一些例子來說明。

  一、基本篇

    一個基本的房間，要有 short <短敘述> 、 long <長敘述>、 exits <出口>

□  當你在寫一個房間的 long <長敘述>時，其格式為：

        set("long", @LONG

房間的敘述.......

LONG
        );

    其中 @LONG 和 LONG  是互相對應的，你可以用任何字接在 @  後面，但是前
後兩個字一定要一樣，這樣系統才能判別，而房間的敘述寫完時，一定要換行後再
接第二個 LONG ，且同一行不能再有其他任何的字元，不然系統無法判定敘述是否
該結束了，會造成編譯時的錯誤。

    而為求區域看起來外觀上整齊、統一，房間的長敘述中每一行的長度必須一樣
，而一行的長度建議為 29 到 32 個中文字，約佔螢幕的三分之二。並且一個房間
的敘述最好不要低於三行，區域各個房間的敘述重復性降到越低越好，這樣你的區
域看起來才不會太過陽春。當然，有時候為了某些目的，比如一個迷宮，你可能會
相鄰的幾個房間都用到一樣的敘述，那自然不在此限。

□  一個房間的出口則以下列格式賦予：

        set("exits", ([
                "方向"          : "連接到的房間之檔名",
                ...........
        ]);

    在這裡，為了一個以後區域開放後搬移目錄的便利性，建議採用__DIR__ 這個
由系統提供的巨集來寫路徑，比如說：

                "west"          : __DIR__"path3",
        和
                "west"          : "/u/d/davidoff/goathill/path3",

是完全一樣的。但前者顯然在以後目錄的搬移上方便的多。而在下面會提到設定房
間中的物品或生物時，也建議採用這種方式寫作。

□  item_desc 這是用來設定個別景物的描述，當玩家用 look 這個指令時就會作
    用。其格式為：

        set("item_desc", ([
                "景物名稱"      : "景物敘述",
                ...........
        ]);

    其中景物敘述可以是字串或是一個 function ，所以你可以利用這個功能加以
變化，當玩家 look 一個景物時，可能看到敘述，也可能發生一些特殊的事件，而
你就可以在被呼叫的函式中寫下這些事件。

□  objects 可以讓這個房間在每次 reset時載入某些生物或某些物品：

        set("objects", ([
                "物品或生物的檔名"      : 數量,
                ...........
        ]);

    如同前面所提到的，建議採用 __DIR__來編寫你的路徑，而數量則要用整數。

□  要為這個房間添上門戶時，記得前面必須先 #include <room.h>。而格式為：

        create_door("出口方向", "門的名稱", "進入方向", 預設狀態);

    比如說，這裡明顯的出口有 west、east 和 up。 而你要讓西邊有一個關上的
紅木門，你可以這樣寫：

        create_door("west", "紅木門", "east", DOOR_CLOSED);

    當玩家進入這個房間時，他會看到：

        這裡明顯的出口有 east 和 up。

    而當他 look west 時，會看到：這個紅木門是關上的。


    其他的一些屬性，你可以參考 /doc/build/room_prop 或是讀一下標準物件的
room.c。也建議你可以多用 more here來觀看一間特殊的 room。
  二、進階篇

    要讓你的區域中富有變化，生動有趣，除了文字敘述的豐富度以外，你更可以
利用 init() 這個函式為你的房間增加一些「機關」或「秘密」。

    這裡，先讓我們了解一下 init() 的用途為何，和為什麼要用到它。每一個房
間的 create() 只有當 reset時才會被呼叫到，而 init() 則是在 B物件進入到 A
物件時都會呼叫到 A物件的 init() 。看到這，你應該可以看出差別了，我們希望
當一個物件（此處較多是玩家）進到一個房間時，能夠經由某個動作啟動這個房間
的機關的話，自然是利用 init() 來編寫。

    一般的使用方式，是在 init() 中利用 add_action() 來呼叫你寫的函式，其
格式為：
        add_action("function type", "action");

    function type 即是被呼叫的函式名    action 是啟動的動作

    而你就可以將被 action 啟動後要發生的事，都寫在被呼叫的函式裡面。理論
上來說，利用這個方式我們可以做到任何事，當然，能不能達成就看寫程式的功力
了。下面舉個簡單的例子：

void init()
{
        add_action("do_pick", "pick");
}

int do_pick(string arg)
{
        object me;

        me = this_player();
        if ( !arg || ( arg != "flower" ) ) return notify_fail("你要摘什麼？\n");

        else if ( random((int)me->query("kar")) < 7 )
                message_vision("$N將花摘了下來，但一不小心被刺了一下。\n", me);

        else
                message_vision("$N摘下一朵美麗的血紅色鮮花。\n", me);

        return 1;
}

    當玩家利用 pick 這個指令時就會呼叫到 do_pick() 這個 function，而啟動了
這個房間的機關。

    這裡特別提到一點，一個簡單的 room 我們為了使記憶體的使用量降到最低，會
在 create() 最後加上一行 replace_program(ROOM); 。這是因為在房間的標準物件
中有定義了如 init() 等其他的函式，而一個簡單的房間根本沒有用到，所以我們用
replace_program() 來將原本的被繼承的標準物件「重置」（或說取代）掉，但是一
旦房間中用到了 init() 來編寫時，就絕對不可以用 replace_program()，因為系統
屆時找不到 init() 便會隨便呼叫一個記憶體中的位址而隨便傳進一些亂七八糟的東
西，情況嚴重時，甚至可以讓整個 mud crash。但是，我們自不可因噎廢食，該用的
時候還是要用，這些應該是一個好的程式寫作人員自己必須留意的，發生狀況要自己
負責。

  三、建議

    這裡我們提供了一個工具來讓巫師們可以方便的編寫一個房間，那就是房間編輯
器(Roommaker) ，你可以 clone /obj/roommaker 來使用它。一般的步驟是，先利用
mkroom來造一個空房間，然後利用 goto 這個指令到房間裡去，再用 rset short 和
connect 來設定這個房間的短敘述及出口，而像其他的一些屬性例如 outdoors 等等
也都可以利用他來做到，接著用 to rset long 來設定這個房間的長敘述，最後再用
saveroom將這個房間存檔。要是這只是一個基本的房間，那到這裡就大功告成了，要
是□想讓這個房間富有變化，那就再用線上編輯器 edit 或將這個房間的檔案 ftp
回去繼續修改。

□ 如何寫一個非玩者人物(NPC)

一.年齡:
   由於系統將會依年齡而計算出, 該怪物之天賦及基本狀態。
   故請務必設定怪物的年齡。

   設定方法: set( "age", 數值 );

二.天賦: (請參考 help gift)
   str = 膂力, cor = 膽識, int = 悟性, spi = 靈性,
   cps = 定力, per = 容貌, con = 根骨, kar = 福緣。

   設定方式: set( "屬性", 數值 );
   數值□圍: 10 - 30

三.狀態: (請參考 help stats)
   gin = 精, kee = 氣, sen = 神。
   atman = 靈力, force = 內力, mana = 法力。

   設定方式: 例如, set( "gin", 200 );
                   set( "max_gin", 200 );
                   set( "force_factor", 3 );

四.經驗:
   對一般沒有特殊技能的怪物而言, 戰鬥經驗(combat_exp)
   幾乎決定了怪物的強度。而綜合評價(score)則決定了玩家
   擊敗此怪物後, 是否能大舉提高自己的綜合評價。

   設定方式: set( "combat_exp", 數值 );
             set( "score", 數值 );

五.技能:
   如果想做些較厲害的怪物或導師(讓玩家學技能)時, 最好的方
   式即是設定技能。

   設定方式:
            1.怪物學過的技能: set( "技巧名", 數值 );
            2.怪物施展的技能: map_skill( "技巧種類", "技巧名" );

   當使用 map_skill() 時, 請務必確定技巧種類是否相符。目前,
   技巧種類如下:
   刀法(blade): spring-blade
   輕功(dodge): chaos-steps pyrobat-steps nine-moon-steps stormdance
   內功(essence): fonxanforce celestial iceforce gouyee nine-moon-force
   修行(evolution):
   法術(magic):
   招架(parry): 各種高級持械功夫
   棍法(stick):
   劍法(sword): fonxansword six-chaos-sword nine-moon-sword
   暗器(throwing):
   拳腳(unarmed): liuh-ken celestrike nine-moon-claw tenderzhi ...
   咒術(spells): necromancy

//希望能把所有技能列於其後//
六.種族:
   如果未指定種族, 系統將會自動選定人類。

   設定方式: set( "race", "種族名" );

七.性別:
   依種族之不同, 有兩種系統: 1.男性, 女性。
                             2.雄性, 雌性, 中性。

   設定方式: set( "gender", "性別" );

八.攻擊:
   攻擊模式包括攻擊方式及受功部位。如果種族是人類, 將直接
   繼承標準模式, 不須額外設定; 其餘種族則一定要加以設定。
   設定方式: set( "verbs", ({ "攻擊方式1", "攻擊方式2", ...}) );
             set( "limbs", ({ "受功部位1", "受功部位2", ...}) );

   目前之種族如下表:

   種族    性別    攻擊方式        受功部位
  ------------------------------------------
   人類     1      系統給定        系統給定
  .........................................
   野獸     2      hoof, bite,     自由設定
                   claw, poke
  ------------------------------------------

九.暗語:
   我們可以在怪物上設定某些暗語, 使得當玩家詢問(ask)特定之
   關鍵字時, 怪物能自動做我們預設之動作。

   設定方式: set( "inquiry", ([
                  "暗語1" : "回應之語\n",
                  "暗語2" : (: this_object(), "呼叫副程式之名" :)
                ]) );

十.其它:
   其餘之設定如: set_name(), set_short(), set_long(), create_family(),
                 set( "nickname", "?" );
                另文敘述!

□ 制作 emote:

角色伴演遊戲中除了談話外還常常會用到一些動作, 表情等來輔助
或用以表達一些不容易「說」出來的感覺. 這類指令通常叫作 emote.
雖然說中文的 emote 指令是可能的, 但為了方便起見, emote 都以
使用英文動詞為主.

emote 由 /adm/daemons/emoted.c 管理.

有關 emote 的指令:
edemote -- 修改, 刪除, 顯示一個 emote 的內容.
semote  -- 顯示目前 emote daemon 所知道的 emote.

emote 分為三種: 有目標, 沒有目標和對自己.

在制作有目標的 emote 時, 你要考慮三個「版本」的訊息:
1. 執行者 - 你自己, 執行這個 emote 的人.
2. 對象   - 你用 emote 的目標. 比方說 'smile A' 時, A 就是對象.
3. 其他人 - 除了你和目標外所有在場的人.

對於沒有目標或對自己的 emote, 則只要考慮 1 跟 3 兩種訊息.

任何訊息都可以有很多行.

訊息的代換參數:
$N -- 你的中文名字.
$n -- 對像的中文名字.
$P -- 自己的人稱代名詞, 如你, □, 他, 她...
$p -- 對象的人稱代名詞, 同上.

□例:
假設我們要做一個 'bore' emote:
>edemote bore

編輯 emote：bore
訊息可以有好幾行，用 . 表示結束。
訊息中可使用的參數有以下幾種：
  $N  自己的名字。
  $n  使用對象的名字。
  $P  自己的人稱代名詞，如你、□、他、她、它、它。
  $p  使用對象的人稱代名詞，如你、□、他、她、它、它。
────────────────────────────────────
不指定對象使用這個 emote 時，你自己看到的訊息：
->$P覺得這裡很無聊.
->.
不指定對象使用這個 emote 時，其他人看到的訊息：
->$N覺得這裡很無聊.
->.
對自己使用這個 emote 時，自己看到的訊息：
->$P覺得$P自己很無聊.
->.
對自己使用這個 emote 時，其他人看到的訊息：
->$N覺得$P自己很無聊.
->.
對別人使用這個 emote 時，自己看到的訊息：
->$P覺得$n很無聊.
->.
對別人使用這個 emote 時，使用對象看到的訊息：
->$N覺得$p很無聊.
->.
對別人使用這個 emote 時，除你自己和使用對象外，其他人看到的訊息：
->$N覺得$n很無聊.
->.
Emote 編輯結束。

當你 (某甲) 使用這個 emote 時:
> bore
[你看到]   : 你覺得這裡很無聊.
[別人看到] : 某甲覺得這裡很無聊.
> bore 某甲  (這裡也可以使用某甲的英文 ID)
[你看到]   : 你覺得你自己很無聊.
[別人看到] : 某甲覺得他自己很無聊.
> bore 某乙
[你看到]   : 你覺得某乙很無聊.
[某乙看到] : 某甲覺得你很無聊.
[別人看到] : 某甲覺得某乙很無聊.

□ 如何架設 ES2類 mudlib

(1) MudOS 部份

  首先，你要有一份 MudOS (最好是 v21c2 版)，而且因為中文的關系，在
  compile 之前需要做一些修改。為了節省您的時間，建議您從 comm.c 的
  telnet_neg() 函數與 ed.c 的 prntln() 函數下手，對 C 語言稍有基礎
  的人應該很容易就能看出該如何修改，在此就不贅言了。

  其次，您必須將 MudOS 正確無誤地 compile 出可執行檔，在開始 compile
  之前，您必須先設定好 options.h 的內容，ES2 mudlib 的 options.h
  也可以從我們提供的 ftp site 得到，如果您無法確定一些選項要如何設定
  ，請參考該檔案。

  接下來，在正常的情況下只要在 src 子目錄下打 make 就可以作出兩個可
  執行檔：driver 跟 addr_server，如果出了其他編譯上的問題，請您請教
  SYSOP。

(2) Install

  當您有了 MudOS 執行檔之後，就可以開始架設 ES2 mudlib，在 es2目錄下
  /adm/etc/config.ES2 是用來當作 MudOS driver 參數的 runtime config
  file，請您將這個檔案拷貝到 driver 的目錄下，然後用文書編輯器修改裡
  面 mudlib directory 跟 binary directory 這兩個路徑為您存放 ES2
  mudlib 以及 driver 可執行檔的絕對路徑，這個檔案中除了前面所說的兩
  個路徑以外，其他有關路徑的設定都是相對於 mudlib 的路徑，如果您對
  mudlib 還不是很熟悉，請勿更改。

  到這裡如果一切都正常，您只要在 driver 的目錄下用：

  driver config.ES2 &

  就可以啟動了，當您看到 Setting up IPC on port XXXX (XXXX 是您在
  config.ES2 中設定要讓 mud 使用的 port 號碼)，就表示安裝成功了。

(3) 如何創造第一個人物

  當您拿到這份 mudlib 的時候，會發現並沒有任何人物資料檔，請您在 es2
  目錄下, adm/etc/wizlist 中加上您的名字，以及一個 (admin)，(admin)
  表示具有最高的權限等級，wizlist 這個檔案是用來儲存所有巫師的等級，
  而且不管人物存在與否，所以請您只留下自己，將其他不存在的人物刪掉。

  接下來您重新啟動 MudOS，然後連線進去創造您剛才設定的人物，您會發現
  這名人物的狀態一開始就是 (admin)，接下來您就可以用 promote 指令將
  其他人擢升為巫師，promote 會自動將這些人物的等級寫入 wizlist。
